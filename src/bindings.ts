
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async changeBinding(id: string, binding: string) : Promise<Result<BindingResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_binding", { id, binding }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetBinding(id: string) : Promise<Result<BindingResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_binding", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Reset multiple bindings atomically to their defaults.
 * This bypasses duplicate checking between the bindings being reset,
 * which solves the issue where resetting A then B fails if A's default
 * conflicts with B's current value.
 */
async resetBindings(ids: string[]) : Promise<Result<BindingResponse[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_bindings", { ids }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAudioFeedbackSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_audio_feedback_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAudioFeedbackVolumeSetting(volume: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_audio_feedback_volume_setting", { volume }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeSoundThemeSetting(theme: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_sound_theme_setting", { theme }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeStartHiddenSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_start_hidden_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAutostartSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_autostart_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeTranslateToEnglishSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_translate_to_english_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeSelectedLanguageSetting(language: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_selected_language_setting", { language }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeOverlayPositionSetting(position: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_overlay_position_setting", { position }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeDebugModeSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_debug_mode_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeWordCorrectionThresholdSetting(threshold: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_word_correction_threshold_setting", { threshold }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePasteMethodSetting(method: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_paste_method_setting", { method }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableTypingTools() : Promise<string[]> {
    return await TAURI_INVOKE("get_available_typing_tools");
},
async changeTypingToolSetting(tool: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_typing_tool_setting", { tool }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeClipboardHandlingSetting(handling: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_clipboard_handling_setting", { handling }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAutoSubmitSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_auto_submit_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAutoSubmitKeySetting(key: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_auto_submit_key_setting", { key }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessBaseUrlSetting(providerId: string, baseUrl: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_base_url_setting", { providerId, baseUrl }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessApiKeySetting(providerId: string, apiKey: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_api_key_setting", { providerId, apiKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessModelSetting(providerId: string, model: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_model_setting", { providerId, model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setPostProcessProvider(providerId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_post_process_provider", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchPostProcessModels(providerId: string) : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_post_process_models", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addPostProcessPrompt(name: string, prompt: string) : Promise<Result<LLMPrompt, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_post_process_prompt", { name, prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updatePostProcessPrompt(id: string, name: string, prompt: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_post_process_prompt", { id, name, prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deletePostProcessPrompt(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_post_process_prompt", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setPostProcessSelectedPrompt(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_post_process_selected_prompt", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateCustomWords(words: CustomWordEntry[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_custom_words", { words }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Temporarily unregister a binding while the user is editing it in the UI.
 * This avoids firing the action while keys are being recorded.
 */
async suspendBinding(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("suspend_binding", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Re-register the binding after the user has finished editing.
 */
async resumeBinding(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resume_binding", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeMuteWhileRecordingSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_mute_while_recording_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAppendTrailingSpaceSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_append_trailing_space_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePasteLastUseSmartInsertionSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_paste_last_use_smart_insertion_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeFillerWordFilterSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_filler_word_filter_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeHallucinationFilterSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_hallucination_filter_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAppLanguageSetting(language: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_app_language_setting", { language }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeUpdateChecksSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_update_checks_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeShowTrayIconSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_show_tray_icon_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeShowUnloadModelInTraySetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_show_unload_model_in_tray_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getUserProfileCommand() : Promise<Result<UserProfile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_user_profile_command") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update a specific field in the user profile.
 * The value is a JSON-encoded string.
 */
async updateUserProfileSetting(key: string, value: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_user_profile_setting", { key, value }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async triggerUpdateCheck() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("trigger_update_check") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelOperation() : Promise<void> {
    await TAURI_INVOKE("cancel_operation");
},
async getAppDirPath() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_dir_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAppSettings() : Promise<Result<AppSettings, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDefaultSettings() : Promise<Result<AppSettings, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_default_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetAppSettings() : Promise<Result<AppSettings, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_app_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getLogDirPath() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_log_dir_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setLogLevel(level: LogLevel) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_log_level", { level }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openRecordingsFolder() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_recordings_folder") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openLogDir() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_log_dir") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openAppDataDir() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_app_data_dir") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if Apple Intelligence is available on this device.
 * Called by the frontend when the user selects Apple Intelligence provider.
 */
async checkAppleIntelligenceAvailable() : Promise<boolean> {
    return await TAURI_INVOKE("check_apple_intelligence_available");
},
/**
 * Log a message from the frontend to the unified log file.
 * This enables session-correlated logging across Rust, Python, and Frontend.
 */
async logFromFrontend(level: string, sessionId: string | null, target: string, message: string) : Promise<void> {
    await TAURI_INVOKE("log_from_frontend", { level, sessionId, target, message });
},
/**
 * Set the onboarding paste override.
 * When true, forces Direct paste method to work around WebView not receiving
 * CGEvent-simulated Cmd+V keystrokes from the same process.
 */
async setOnboardingPasteOverride(enabled: boolean) : Promise<void> {
    await TAURI_INVOKE("set_onboarding_paste_override", { enabled });
},
/**
 * Try to initialize Enigo (keyboard/mouse simulation).
 * Uses the lazy-init EnigoState - calls try_init() to initialize if not already done.
 * On macOS, this will fail if accessibility permissions are not granted.
 */
async initializeEnigo() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("initialize_enigo") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Initialize keyboard shortcuts.
 * On macOS, this should be called after accessibility permissions are granted.
 * This is idempotent - calling it multiple times is safe.
 */
async initializeShortcuts() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("initialize_shortcuts") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableModels() : Promise<Result<ModelInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_models") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getModelInfo(modelId: string) : Promise<Result<ModelInfo | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_model_info", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async downloadModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelDownload(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_download", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setActiveModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_active_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCurrentModel() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_current_model") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTranscriptionModelStatus() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_transcription_model_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isModelLoading() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_model_loading") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hasAnyModelsAvailable() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("has_any_models_available") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hasAnyModelsOrDownloads() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("has_any_models_or_downloads") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRecommendedFirstModel() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recommended_first_model") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateMicrophoneMode(alwaysOn: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_microphone_mode", { alwaysOn }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getMicrophoneMode() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_microphone_mode") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableMicrophones() : Promise<Result<AudioDevice[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_microphones") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setSelectedMicrophone(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_selected_microphone", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSelectedMicrophone() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_selected_microphone") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableOutputDevices() : Promise<Result<AudioDevice[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_output_devices") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setSelectedOutputDevice(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_selected_output_device", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSelectedOutputDevice() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_selected_output_device") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async playTestSound(soundType: string) : Promise<void> {
    await TAURI_INVOKE("play_test_sound", { soundType });
},
async checkCustomSounds() : Promise<CustomSounds> {
    return await TAURI_INVOKE("check_custom_sounds");
},
async setClamshellMicrophone(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_clamshell_microphone", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getClamshellMicrophone() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_clamshell_microphone") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isRecording() : Promise<boolean> {
    return await TAURI_INVOKE("is_recording");
},
/**
 * Start microphone preview mode - opens the mic stream to emit levels without recording
 */
async startMicPreview() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_mic_preview") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop microphone preview mode - closes the mic stream
 */
async stopMicPreview() : Promise<void> {
    await TAURI_INVOKE("stop_mic_preview");
},
async setModelUnloadTimeout(timeout: ModelUnloadTimeout) : Promise<void> {
    await TAURI_INVOKE("set_model_unload_timeout", { timeout });
},
async getModelLoadStatus() : Promise<Result<ModelLoadStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_model_load_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async unloadModelManually() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unload_model_manually") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getHistoryEntries(limit: number, offset: number, searchQuery: string | null, starredOnly: boolean, timePeriodStart: number | null) : Promise<Result<HistoryEntry[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_history_entries", { limit, offset, searchQuery, starredOnly, timePeriodStart }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async toggleHistoryEntrySaved(id: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("toggle_history_entry_saved", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAudioFilePath(fileName: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_audio_file_path", { fileName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteHistoryEntry(id: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_history_entry", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateHistoryLimit(limit: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_history_limit", { limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateRecordingRetentionPeriod(period: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_recording_retention_period", { period }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getHomeStats() : Promise<Result<HomeStats, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_home_stats") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async clearAllHistory() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_all_history") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getHistoryStorageUsage() : Promise<Result<HistoryStats, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_history_storage_usage") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async pruneHistory(days: number) : Promise<Result<number, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("prune_history", { days }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks if the Mac is a laptop by detecting battery presence
 * 
 * This uses pmset to check for battery information.
 * Returns true if a battery is detected (laptop), false otherwise (desktop)
 */
async isLaptop() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_laptop") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all available MLX models with their current status
 */
async mlxListModels() : Promise<Result<MlxModelInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("mlx_list_models") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the status of a specific MLX model
 */
async mlxGetModelStatus(modelId: string) : Promise<Result<MlxModelInfo | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("mlx_get_model_status", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start downloading an MLX model from Hugging Face Hub
 */
async mlxDownloadModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("mlx_download_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Cancel an in-progress MLX model download
 */
async mlxCancelDownload() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("mlx_cancel_download") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Retry a failed MLX model download (max 3 attempts)
 */
async mlxRetryDownload() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("mlx_retry_download") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a downloaded MLX model
 * Returns an error if the model is currently in use
 */
async mlxDeleteModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("mlx_delete_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Process text using the loaded MLX model
 * This is used for transcription post-processing
 */
async mlxProcessText(prompt: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("mlx_process_text", { prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if any MLX model operation is currently in progress
 */
async mlxIsBusy() : Promise<boolean> {
    return await TAURI_INVOKE("mlx_is_busy");
},
/**
 * Unload the currently loaded MLX model to free memory
 */
async mlxUnloadModel() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("mlx_unload_model") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Switch to a different MLX model
 * Unloads the current model and prepares for the new one to be loaded on next use
 */
async mlxSwitchModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("mlx_switch_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Open the specific MLX model folder in Finder/Explorer
 */
async mlxOpenModelsDir(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("mlx_open_models_dir", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start Fn key monitoring using CGEventTap
 * This sets up an event tap to detect Fn key presses via kCGEventFlagsChanged events
 * When enable_transcription is true, pressing Fn will trigger the transcribe action
 * If the monitor is already active, this will update the transcription flag without restarting
 */
async startFnKeyMonitor(enableTranscription: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_fn_key_monitor", { enableTranscription }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop Fn key monitoring
 */
async stopFnKeyMonitor() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_fn_key_monitor") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Open System Settings to the Accessibility privacy pane
 */
async openAccessibilitySettings() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_accessibility_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Open System Settings to the Microphone privacy pane
 */
async openMicrophoneSettings() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_microphone_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async showMainWindow() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("show_main_window") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setUpdateMenuText(text: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_update_menu_text", { text }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async acceptCorrection() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("accept_correction") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dismissCorrection() : Promise<void> {
    await TAURI_INVOKE("dismiss_correction");
},
async undoOverlayCardDismissed() : Promise<void> {
    await TAURI_INVOKE("undo_overlay_card_dismissed");
},
async undoOverlayCardPresented() : Promise<void> {
    await TAURI_INVOKE("undo_overlay_card_presented");
},
async undoMarkDiscoverabilityHintSeen() : Promise<void> {
    await TAURI_INVOKE("undo_mark_discoverability_hint_seen");
},
async overlayUpdateInteractionRegions(regions: OverlayInteractionRegionsPayload) : Promise<void> {
    await TAURI_INVOKE("overlay_update_interaction_regions", { regions });
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AppSettings = { bindings: Partial<{ [key in string]: ShortcutBinding }>; audio_feedback: boolean; audio_feedback_volume?: number; sound_theme?: SoundTheme; start_hidden?: boolean; autostart_enabled?: boolean; update_checks_enabled?: boolean; selected_model?: string; always_on_microphone?: boolean; selected_microphone?: string | null; clamshell_microphone?: string | null; selected_output_device?: string | null; translate_to_english?: boolean; selected_language?: string; saved_languages?: string[]; overlay_position?: OverlayPosition; debug_mode?: boolean; log_level?: LogLevel; dictionary?: CustomWordEntry[]; model_unload_timeout?: ModelUnloadTimeout; word_correction_threshold?: number; word_correction_split_threshold?: number; history_limit?: number; recording_retention_period?: RecordingRetentionPeriod; paste_method?: PasteMethod; clipboard_handling?: ClipboardHandling; auto_submit?: boolean; auto_submit_key?: AutoSubmitKey; post_process_enabled?: boolean; post_process_provider_id?: string; post_process_providers?: PostProcessProvider[]; post_process_api_keys?: Partial<{ [key in string]: string }>; post_process_models?: Partial<{ [key in string]: string }>; post_process_prompts?: LLMPrompt[]; post_process_selected_prompt_id?: string | null; 
/**
 * When true, all transcriptions are automatically refined (adds delay).
 * When false (default), user must manually trigger refinement with hotkey.
 */
auto_refine_enabled?: boolean; mute_while_recording?: boolean; append_trailing_space?: boolean; paste_last_use_smart_insertion?: boolean; app_language?: string; 
/**
 * When true, removes filler words (um, uh, hmm, etc.) from transcriptions.
 */
enable_filler_word_filter?: boolean; 
/**
 * When true, collapses repeated/stuttered words caused by ASR hallucinations.
 */
enable_hallucination_filter?: boolean; show_tray_icon?: boolean; show_unload_model_in_tray?: boolean; paste_delay_ms?: number; paste_restore_delay_ms?: number; typing_tool?: TypingTool }
export type AudioDevice = { index: string; name: string; is_default: boolean; is_bluetooth: boolean }
export type AutoSubmitKey = "enter" | "ctrl_enter" | "cmd_enter"
export type BindingResponse = { success: boolean; binding: ShortcutBinding | null; error: string | null }
export type ClipboardHandling = "dont_modify" | "copy_to_clipboard"
export type CustomSounds = { start: boolean; stop: boolean }
export type CustomWordEntry = { input: string; aliases?: string[]; replacement: string; is_replacement: boolean }
export type EngineType = "Whisper" | "Parakeet" | "Moonshine" | "MoonshineStreaming" | "SenseVoice"
export type HistoryEntry = { id: number; file_name: string; timestamp: number; saved: boolean; title: string; transcription_text: string; post_processed_text: string | null; inserted_text: string | null; effective_text: string; raw_text: string; post_process_prompt: string | null; duration_ms: number; file_path: string }
export type HistoryStats = { total_size_bytes: number; total_entries: number }
export type HomeStats = { total_words: number; total_duration_minutes: number; wpm: number; time_saved_minutes: number; streak_days: number; faster_than_typing_percentage: number; total_filler_words_removed: number; filler_filter_active: boolean }
export type LLMPrompt = { id: string; name: string; prompt: string }
export type LogLevel = "trace" | "debug" | "info" | "warn" | "error"
/**
 * Information about an available MLX model
 */
export type MlxModelInfo = { 
/**
 * Unique model identifier
 */
id: string; 
/**
 * Display name for the UI
 */
display_name: string; 
/**
 * Model description
 */
description: string; 
/**
 * Hugging Face repository ID
 */
hf_repo: string; 
/**
 * Approximate size in bytes when downloaded
 */
size_bytes: number; 
/**
 * Current status of the model
 */
status: MlxModelStatus; 
/**
 * Download progress (0.0 - 1.0) when downloading
 */
download_progress: number; 
/**
 * Whether this is the default recommended model
 */
is_default: boolean; 
/**
 * Number of parameters (for display)
 */
parameters: string }
/**
 * Model status enum representing the lifecycle of a model
 */
export type MlxModelStatus = 
/**
 * Model is not downloaded
 */
"not_downloaded" | 
/**
 * Model is currently being downloaded
 */
"downloading" | 
/**
 * Model download failed
 */
"download_failed" | 
/**
 * Model is downloaded but not loaded
 */
"downloaded" | 
/**
 * Model is currently being loaded into memory
 */
"loading" | 
/**
 * Model is loaded and ready for inference
 */
"ready" | 
/**
 * Model loading failed
 */
"load_failed"
export type ModelInfo = { id: string; name: string; description: string; filename: string; url: string | null; size_mb: number; is_downloaded: boolean; is_downloading: boolean; partial_size: number; is_directory: boolean; engine_type: EngineType; accuracy_score: number; speed_score: number; supports_translation: boolean; is_recommended: boolean; supported_languages: string[]; is_custom: boolean }
export type ModelLoadStatus = { is_loaded: boolean; current_model: string | null }
export type ModelUnloadTimeout = "never" | "immediately" | "min_2" | "min_5" | "min_10" | "min_15" | "hour_1" | "sec_5"
export type OverlayClientRect = { x: number; y: number; width: number; height: number }
export type OverlayInteractionRegionsPayload = { overlayVisible: boolean; messageLaneRect: OverlayClientRect | null; actionRects?: OverlayClientRect[] }
export type OverlayPosition = "none" | "top" | "bottom"
export type PasteMethod = "ctrl_v" | "direct" | "none" | "shift_insert" | "ctrl_shift_v"
export type PostProcessProvider = { id: string; label: string; base_url: string; allow_base_url_edit?: boolean; models_endpoint?: string | null; supports_structured_output?: boolean }
export type RecordingRetentionPeriod = "never" | "preserve_limit" | "days_3" | "weeks_2" | "months_3"
export type ShortcutBinding = { id: string; name: string; description: string; default_binding: string; current_binding: string }
export type SoundTheme = "marimba" | "pop" | "custom"
export type TypingTool = "auto" | "wtype" | "kwtype" | "dotool" | "ydotool" | "xdotool"
/**
 * User profile data - separate from app settings.
 * This stores onboarding and user identity information.
 */
export type UserProfile = { 
/**
 * User's display name (collected during onboarding)
 */
user_name?: string | null; 
/**
 * Current onboarding step (1-based index)
 */
onboarding_step?: number; 
/**
 * Whether onboarding has been completed
 */
onboarding_completed?: boolean; 
/**
 * How the user heard about the app (single source stored as array for compat)
 */
referral_sources?: string[]; 
/**
 * Secondary details for referral source (e.g., which social media platform)
 */
referral_details?: Partial<{ [key in string]: string[] }>; 
/**
 * User's work role/profession
 */
work_role?: string | null; 
/**
 * Custom text when "other" work role is selected
 */
work_role_other?: string | null; 
/**
 * Professional level (Executive, Director, Manager, etc.)
 */
professional_level?: string | null; 
/**
 * Typing use cases (multi-select from onboarding)
 */
typing_use_cases?: string[]; 
/**
 * Custom text when "other" typing use case is selected
 */
typing_use_cases_other?: string | null }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
